// test.cpp : 定义控制台应用程序的入口点。
//
//

#include <opencv2/opencv.hpp>
#include <iostream>
using namespace cv ;


#ifdef Debug
int main()
{
	VideoCapture cap ;
	Mat frame , segm;
	cap.open(0) ;

	if(!cap.isOpened())
	{
		std::cerr<<"can't open camera";

		return -1 ;
	}

	namedWindow("FG" , WINDOW_NORMAL);

	for(;;)
	{
		cap >> frame ;

		if(frame.empty())
			break ;

		frame.copyTo(segm) ;

		imshow("FG" , segm) ;
	
		int c = waitKey(30) ;
	
		if(c == 'q' || c == 'Q' || (c & 255) == 27)
			break ;
	}
}
#else 
int main( int argc, char** argv )  
{  
  //声明IplImage指针  
  IplImage* pFrame = NULL;  
  
 //获取摄像头  
  CvCapture* pCapture = cvCreateCameraCapture(0);  
   
  //创建窗口  
  cvNamedWindow("video", 1);  
   
  //显示视屏  
  while(1)  
  {  
      pFrame=cvQueryFrame( pCapture );  
      if(!pFrame)break;  
      cvShowImage("video",pFrame);  
      char c=cvWaitKey(33);  
      if(c=='q')
		  break;  
  }  
  cvReleaseCapture(&pCapture);  
  cvDestroyWindow("video");  
} 

#endif

#ifdef Debug

#include <opencv2/opencv.hpp>
#include <iostream>
#include <string>

using namespace cv ;
using namespace std ;

    void update(void *param)  
    {  
        VideoCapture cap;  
        cap.open("test.avi");  
        if ( !cap.isOpened() )  
        {  
            return ;  
        }  
      
        for(;;)  
        {  
            cap>>frame;  
            //cvNamedWindow("tmp");//加上这个，再使用waitkey就没问题了  
            //waitKey(100);//使用waitkey程序必定崩，主要是因为waitkey是对窗口机制起作用的，即cvNamedWindow产生的窗口，若没有产生的窗口，则waitkey相当于未执行，当视频帧很快的被读完，frame为空，自然就出问题了  
      
            Sleep(100);//若使用Sleep，则能正常工作  
        }     
    }  
      
      
    void main()  
    {  
        _beginthread(update,0,NULL);  
        Sleep(1000);  
        cvNamedWindow("test");  
      
        for(;;)  
        {  
            //判空(省略)          
            imshow("test",*frame);  
            waitKey(100);  
        }  
        waitKey(0);  
    }  
#endif 


#ifdef Debug

int main()
{
   //打开视频文件：其实就是建立一个VideoCapture结构  
    VideoCapture capture("D:/videos/PetsD2TeC2.avi");  
    //检测是否正常打开:成功打开时，isOpened返回ture  
    if(!capture.isOpened())  
        cout<<"fail to open!"<<endl;  
    //获取整个帧数  
    long totalFrameNumber = capture.get(CV_CAP_PROP_FRAME_COUNT);  
    cout<<"整个视频共"<<totalFrameNumber<<"帧"<<endl;  
  
  
    //设置开始帧()  
    long frameToStart = 300;  
    capture.set( CV_CAP_PROP_POS_FRAMES,frameToStart);  
    cout<<"从第"<<frameToStart<<"帧开始读"<<endl;  
  
  
    //设置结束帧  
    int frameToStop = 400;  
  
    if(frameToStop < frameToStart)  
    {  
        cout<<"结束帧小于开始帧，程序错误，即将退出！"<<endl;  
        return -1;  
    }  
    else  
    {  
        cout<<"结束帧为：第"<<frameToStop<<"帧"<<endl;  
    }  
  
  
    //获取帧率  
    double rate = capture.get(CV_CAP_PROP_FPS);  
    cout<<"帧率为:"<<rate<<endl;  
  
  
  
    //定义一个用来控制读取视频循环结束的变量  
    bool stop = false;  
    //承载每一帧的图像  
    Mat frame;  
    //显示每一帧的窗口  
    namedWindow("Extracted frame");  
    //两帧间的间隔时间:  
    //int delay = 1000/rate;  
    int delay = 1000/rate;  
  
  
    //利用while循环读取帧  
    //currentFrame是在循环体中控制读取到指定的帧后循环结束的变量  
    long currentFrame = frameToStart;  
  
  
    //滤波器的核  
    int kernel_size = 3;  
    Mat kernel = Mat::ones(kernel_size,kernel_size,CV_32F)/(float)(kernel_size*kernel_size);  
  
    while(!stop)  
    {  
        //读取下一帧  
        if(!capture.read(frame))  
        {  
            cout<<"读取视频失败"<<endl;  
            waitKey(0) ;    
        }  
          
        //这里加滤波程序  
        imshow("Extracted frame",frame);  
        filter2D(frame,frame,-1,kernel);  
  
        imshow("after filter",frame);  
        cout<<"正在读取第"<<currentFrame<<"帧"<<endl;  
        //waitKey(int delay=0)当delay ≤ 0时会永远等待；当delay>0时会等待delay毫秒  
        //当时间结束前没有按键按下时，返回值为-1；否则返回按键  
  
  
        int c = waitKey(delay);  
        //按下ESC或者到达指定的结束帧后退出读取视频  
        if((char) c == 27 || currentFrame > frameToStop)  
        {  
            stop = true;  
        }  
        //按下按键后会停留在当前帧，等待下一次按键  
        if( c >= 0)  
        {  
            waitKey(0);  
        }  
        currentFrame++;  
      
    }  
    //关闭视频文件  
    capture.release();  
    waitKey(0);  
    return 0;  
}
#endif
